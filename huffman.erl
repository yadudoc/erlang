% P-50
% Huffman code.
% We suppose a set of symbols with their frequencies,
% given as a list of fr(S,F) terms. Example: [fr(a,45),fr(b,13),fr(c,12),
% fr(d,16),fr(e,9),fr(f,5)]. Our objective is to construct a list hc(S,C) terms,
% where C is the Huffman code word for the symbol S. In our example,
% the result could be Hs = [hc(a,'0'), hc(b,'101'), hc(c,'100'), hc(d,'111'), 
% hc(e,'1101'), hc(f,'1100')] [hc(a,'01'),...etc.]. The task shall be performed 
% by the predicate huffman/2 defined as follows: 

% huffman(Fs,Hs) :- Hs is the Huffman code table for the frequency table Fs

-module(huffman).
-export([
	 encode/1,
	 huffman_codes/1
	]).


% List is assumed to a freq sorted list of elements such that
% List is of the format [{5,c}, {8,b}, {19,a}]
encode(List) ->
    go([ [X] || X<-List ]).

go([Hufftree|[]]) ->
    Hufftree;
go(List) ->
    go(code(lists:sort(List))).

code([ [{C1, Char1}|T1] | [ [{C2,Char2}|T2] | T ] ]) ->
    lists:append([[{C1+C2, nil},[{C1, Char1}|T1],[{C2,Char2}|T2]]],code(T));
code([ [{C, Char}|T] | []]) ->
    [[{C,Char}]|T];
code([]) ->
    [].

% huffman_codes/1 takes a huffman tree as input
% the huffman tree could be generated by the encode function
huffman_codes(Tree) ->
    process(Tree, '').

process([{_,nil},Left,Right], Huffcode) ->
    lists:append(
      process(Left , list_to_atom(atom_to_list(Huffcode) ++ "0")),
      process(Right, list_to_atom(atom_to_list(Huffcode) ++ "1"))
     );    
process([{_,nil}] , _) ->
    [];
process([{_,Char}], Huffcode) ->
    [{Char,Huffcode}].
    


    
    
    
    
