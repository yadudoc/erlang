% find n combinations from a given list of items
% Suppose the list is [a,b,c,d,e] N=5 and we need 				
% to find C(N,R=3) of the list. 
% we just add the element generated by appending 
% element a with items generated by C(N-1,R-1)
% and also the elements generated by C(N-1,R)
% 
% After the first step of recursion
% C([a,b,c,d,e],3) = a append C([b,c,d,e],2) + C([b,c,d,e],3)

-module(comb).
-export([c/2]).


c(List, N) ->
    c(List, N, [[]]).

% handle the case with no List passed , this should not happen ideally
c([], _, Acc)->
    Acc;
% case in which we attempt C(N,1) which results each N items
c(List, 1, Acc) ->
    [ lists:append(H,[T]) || H<-Acc,
			     T<-List ];
% the guard is wrong and was done inorder to check C(5,3) condition
c([H|T], N, Acc) when 3 > N ->
    c(T, N-1, [ lists:append(A,[H]) || A<-Acc ]);
% the core statement
% take the head and append to every list returned by combinations 
% of element in the tail with one less item
% also consider the combinations of the same number but from the 
% tail.
c([H|T], N, Acc) ->				                	
    c(T, N-1, [ lists:append(A,[H]) || A<-Acc ]),
    c(T, N, Acc).

% Find the length of the list passed to it.
len([]) ->
    0;
len([_|T]) ->
    1 + len(T).
    
    

   
    

    
    
