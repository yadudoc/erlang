% P26 Alternative logic
% find n combinations from a given list of items
% Suppose the list is [a,b,c,d,e] N=5 and we need 				
% to find C(N,R=3) of the list. 
% we just add the element generated by appending 
% element a with items generated by C(N-1,R-1)
% and also the elements generated by C(N-1,R)
% 
% After the first step of recursion
% C([a,b,c,d,e],3) = a append C([b,c,d,e],2) + C([b,c,d,e],3)

-module(comb).
-export([c/2, appendtoeach/2, len/1]).


c(List, N) ->       
    c(List, N, N).
    



c([H|T], 1, _) ->
%    io:format("Attempting for array: ~p with N: ~p~n",[[H|T],1]),
    [[X] || X<-[H|T]];       

c([H|T], N, Nmax) ->			
%    io:format("Current Head: ~p~n",[H]),
%    io:format("Attempting for array: ~p with N: ~p~n",[[H|T],N]),
    S = c(T, N-1, Nmax),
%    ##### Debugging stuff only ########
%    io:format("Testing  with result ~p and head ~p~n",S),
%    [X|Y] = appendtoeach(H, S) ,   
%    io:format("check T: ~p with N: ~p~n",[T,N]),
%    lists:append(Acc, appendtoeach(H, S) ),

    X = appendtoeach(H, S),
    if
	N =:= Nmax ->
	    [];
%	    io:format("Result at level : ~p with N: ~p~n",[X , N]);

	true ->
	    []
    end,
    Len = len(T),
    if
	Len =:= 2 ->
	    lists:append(X,[T]);
	Len > N , Len >= Nmax ->	    
%	    Y = c(T, N, [], Nmax),
%	    io:format("Attemption for array: ~p  with N: ~p~n",[T,N]),
%	    io:format("Result from C(N-1,R): ~p~n",Y ),
	    lists:append(X, c(T, N, Nmax) );
%	    io:format("Testing  ~p~n",[c(T,N,[])]);	       
	Len =:= N , Len >= Nmax ->
	    lists:append(X,[T]);	
	true ->
	    []
    end
    .




% Find the length of the list passed to it.
len([]) ->
    0;
len([_|T]) ->
    1 + len(T).

% appends an element A to each element in the list 
appendtoeach(A, List) ->
    appendtoeach(A, List, []).   

appendtoeach(A, ok, _) ->
    io:format("Error: appendtoeach passed (~p, ~p)~n",[A,ok]);
appendtoeach(_, [], Acc) ->
    Acc;
appendtoeach(A, [H|T], Acc) ->
    appendtoeach(A, T, lists:append(Acc, [lists:append([A],H)])).

    
    

   
    

    
    
